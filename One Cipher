The One Cipher...
A Authenticated Encryption with Associated Data (AEAD) enhanced Vernan Cipher.
The One Cipher to rule over all others...
*** This is a simplyfied version for 32 and 64 byte key wrpping.

"Anyone intelligent can make things bigger and more complex. It takes a touch of genius – and a lot of courage – to move in the opposite direction” —Albert Einstein

 public class OneCipher
 {
     const int _ivssize = 16;
     public static byte[] XEncrypt(byte[] seed,byte[] data, byte[] aad = null)
     {
         byte[] iv = RandomNumberGenerator.GetBytes(_ivssize);
         // Derive key with length of data 
         byte[] keyBytes = new Shake256().GetCurrentHash(data.Length);
         // CipherText or outbytes
         byte[] outBytes = new byte[keyBytes.Length];

         // Check arguments:
         if (data.Length != keyBytes.Length)
             throw new ArgumentException("Byte-arrays are not of same length");

         // Encrypt by vernan XOR:
         for (int i = 0; i < data.Length; i++)
             outBytes[i] = (byte)(data[i] ^ keyBytes[i]);

         // Generate authenticated TAG to address Vernam Cipher malleability
         byte[] _key = seed.Take(32).ToArray(); // take one of the compressed medly set, to generate tag..
         byte[] _tag;

         // Process optional aad
         if (aad == null)
             _tag = ComputeTag(_key, outBytes);
         else
             _tag = ComputeTag(_key, outBytes.Concat(aad).ToArray()); // simple concat as no padding used in vernan ciphers.

         CryptographicOperations.ZeroMemory(keyBytes);
         return iv.Concat(_tag).Concat(outBytes).ToArray();

     }

     /// <summary>
     /// HMACSHA256-128
     /// Compute 16 byte (128 bit) Tag
     /// </summary>
     /// <param name="key"></param>
     /// <param name="data"></param>
     /// <returns></returns>
     private static byte[] ComputeTag(byte[] key, byte[] data)
     {
         if (key.Length > 32)
             key = key.Take(32).ToArray();
         byte[] output = new byte[_ivssize];
         HMAC hmac = new HMACSHA256(key);
         Array.Copy(hmac.ComputeHash(data), output, _ivssize);
         return output;
     }

 }
