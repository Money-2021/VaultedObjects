The One Cipher...
A Authenticated Encryption with Associated Data (AEAD) enhanced Vernan Cipher.
The One Cipher to rule over all others...
*** This is a simplyfied (non key generator) version for usage within the End Point <-> Host schannel.

"Anyone intelligent can make things bigger and more complex. It takes a touch of genius – and a lot of courage – to move in the opposite direction” —Albert Einstein

 public class OneCipher
 {
     const int _ivssize = 16;
     const int _macsize = 16; 
     public static byte[] XEncrypt(byte[] seed,byte[] data, byte[] aad = null)
     {
         byte[] iv = RandomNumberGenerator.GetBytes(_ivssize);
         // Derive key with length of data 
         byte[] keyBytes = new Shake256().GetCurrentHash(data.Length);
         // CipherText or outbytes
         byte[] outBytes = new byte[keyBytes.Length];

         // Check arguments:
         if (data.Length != keyBytes.Length)
             throw new ArgumentException("Byte-arrays are not of same length");

         // Encrypt by vernan XOR:
         for (int i = 0; i < data.Length; i++)
             outBytes[i] = (byte)(data[i] ^ keyBytes[i]);

         // Generate authenticated TAG to address Vernam Cipher malleability
         byte[] _key = seed.Take(32).ToArray(); // take one of the compressed medly set, to generate tag..
         byte[] _tag;

         // Process optional aad
         if (aad == null)
             _tag = ComputeTag(_key, outBytes);
         else
             _tag = ComputeTag(_key, outBytes.Concat(aad).ToArray()); // simple concat as no padding used in vernan ciphers.

         CryptographicOperations.ZeroMemory(keyBytes);
         return iv.Concat(_tag).Concat(outBytes).ToArray();

     }

 /// <summary>
 /// Extended Decrypt, variable length data with fixed 64 byte seed/key
 /// </summary>
 /// <param name="seed"></param>
 /// <param name="cipherBytes"></param>
 /// <param name="aad">additional authenticated data</param>
 /// <returns></returns>
 /// <exception cref="ArgumentException"></exception>
 /// <exception cref="Exception"></exception>
 public static byte[] XDerypt(byte[] seed, byte[] cipherBytes,byte[] aad = null)
 {
   
     // Calaulate cipher Length
     int cipherLength = cipherBytes.Length - (_ivssize + _macsize);
               
     var iv = new byte[_ivssize];
     var tag = new byte[_macsize];
     var ciphertext = new byte[cipherLength];

     // Extract
     Buffer.BlockCopy(cipherBytes, 0, iv, 0, _ivssize);
     Buffer.BlockCopy(cipherBytes, _ivssize, tag, 0, _macsize);
     Buffer.BlockCopy(cipherBytes, _ivssize + _macsize, ciphertext, 0, cipherLength);

     // Derive data length key
     byte[] keyBytes = KeyGenerator.Create(seed, iv).KeyGen(cipherLength);

     byte[] outBytes = new byte[cipherLength];

     // Check arguments:
     if ((ciphertext.Length != keyBytes.Length) ||
         (keyBytes.Length != outBytes.Length))
         throw new ArgumentException("Byte-array are not of same length");

     // Compute MAC
     byte[] _key = seed.Take(32).ToArray();
     byte[] _tag;
     // Process optional aad
     if (aad == null)
         _tag = ComputeTag(_key, ciphertext);
     else
         _tag = ComputeTag(_key, ciphertext.Concat(aad).ToArray());

     // Check tag 
     bool bResult = tag.SequenceEqual(_tag);
     if (bResult == false)
         throw new Exception("Tag Error..");

     // Decrypt by XOR:
     for (int i = 0; i < ciphertext.Length; i++)
         outBytes[i] = (byte)(ciphertext[i] ^ keyBytes[i]);
     // Clean
     CryptographicOperations.ZeroMemory(keyBytes);
     return outBytes;

 }

     /// <summary>
     /// HMACSHA256-128
     /// Compute 16 byte (128 bit) Tag
     /// </summary>
     /// <param name="key"></param>
     /// <param name="data"></param>
     /// <returns></returns>
     private static byte[] ComputeTag(byte[] key, byte[] data)
     {
         if (key.Length > 32)
             key = key.Take(32).ToArray();
         byte[] output = new byte[_ivssize];
         HMAC hmac = new HMACSHA256(key);
         Array.Copy(hmac.ComputeHash(data), output, _ivssize);
         return output;
     }

 }
